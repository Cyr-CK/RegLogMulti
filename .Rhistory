names(prob_dist),
sum(is.na(x)),
replace = TRUE,
prob = prob_dist
)
} else {
stop("Unsupported imputation type")
}
}
)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of data after imputation
transform = function(data) {
for (col in names(self$imputation_values)) {
data[[col]][is.na(data[[col]])] <- self$imputation_values[[col]]
}
return(data)
},
#' @description
#' Fit to data object following the specified method then impute NA
#' @param data Dataframe
#' @param columns Vector of column names that will get imputation (must be of qualitative type)
#' @return Dataframe of data after imputation
fit_transform = function(data, columns) {
self$fit(data, columns)
return(self$transform(data))
}
)
)
?Simple.Quali.Imputer
imputer <- Simple.Quali.Imputer$new()
?Simple.Quali.Imputer
??Simple.Quali.Imputer
library(R6)
?Simple.Quali.Imputer
#' Factor Analysis of Mixed Data
#'
#' @description
#' Class of a FAMD object that has fit, fit_transform and transform methods to embed the qualitative and quantitative features into a new quantitative coordinates system
#'
#' @details
#'
#' @import R6
#' @import FactoMineR
#' @export
#'
#' @examples
#' famd <- FAMD_$new()
#'
#' X_train_famd <- famd$fit_transform(X_train)
#'
#' famd$fit(X_train)
#' X_test_famd <- famd$transform(X_test)
FAMD_ <- R6::R6Class("FAMD_",
public = list(
#' @field model FAMD object
model = NULL,
#' @field n_components Number of components to keep from the new coordinates system
n_components = NULL,
#' @description
#' Create a new FAMD object
#' @param n_components Number of components
#' @return A new FAMD object
initialize = function(n_components = NULL){
self$n_components <- n_components
},
#' @description
#' Fit the FAMD model to data
#' @param data Dataframe
fit = function(data){
if (!is.data.frame(data)){
stop("Data are not in a dataframe format")
}
if (self$n_components = NULL){
self$n_components <- ncol(data)
}
self$model <- FactoMineR::FAMD(data, ncp=self$n_components, graph=FALSE)
invisible(self)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of new data coordinates
transform = function(data){
if (is.null(self$model)){
stop("Fit() method must be used before transform()")
}
coord <- predict(self$model, data)$coord
return(as.data.frame(coord[, 1:self$n_components]))
},
#' @description
#' Fit to data object then model it with FAMD
#' @param data Dataframe
#' @return Dataframe of new data coordinates
fit_transform = function(data){
self$fit(data)
self$transform(data)
}
),
)
#' Factor Analysis of Mixed Data
#'
#' @description
#' Class of a FAMD object that has fit, fit_transform and transform methods to embed the qualitative and quantitative features into a new quantitative coordinates system
#'
#' @details
#'
#' @import R6
#' @import FactoMineR
#' @export
#'
#' @examples
#' famd <- FAMD_$new()
#'
#' X_train_famd <- famd$fit_transform(X_train)
#'
#' famd$fit(X_train)
#' X_test_famd <- famd$transform(X_test)
FAMD_ <- R6::R6Class("FAMD_",
public = list(
#' @field model FAMD object
model = NULL,
#' @field n_components Number of components to keep from the new coordinates system
n_components = NULL,
#' @description
#' Create a new FAMD object
#' @param n_components Number of components
#' @return A new FAMD object
initialize = function(n_components = NULL){
self$n_components <- n_components
},
#' @description
#' Fit the FAMD model to data
#' @param data Dataframe
fit = function(data){
if (!is.data.frame(data)){
stop("Data are not in a dataframe format")
}
if (self$n_components = NULL){
self$n_components <- ncol(data)
}
self$model <- FactoMineR::FAMD(data, ncp=self$n_components, graph=FALSE)
invisible(self)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of new data coordinates
transform = function(data){
if (is.null(self$model)){
stop("Fit() method must be used before transform()")
}
coord <- predict(self$model, data)$coord
return(as.data.frame(coord[, 1:self$n_components]))
},
#' @description
#' Fit to data object then model it with FAMD
#' @param data Dataframe
#' @return Dataframe of new data coordinates
fit_transform = function(data){
self$fit(data)
self$transform(data)
}
),
)
#' Factor Analysis of Mixed Data
#'
#' @description
#' Class of a FAMD object that has fit, fit_transform and transform methods to embed the qualitative and quantitative features into a new quantitative coordinates system
#'
#' @details
#'
#' @import R6
#' @import FactoMineR
#' @export
#'
#' @examples
#' famd <- FAMD_$new()
#'
#' X_train_famd <- famd$fit_transform(X_train)
#'
#' famd$fit(X_train)
#' X_test_famd <- famd$transform(X_test)
FAMD_ <- R6::R6Class("FAMD_",
public = list(
#' @field model FAMD object
model = NULL,
#' @field n_components Number of components to keep from the new coordinates system
n_components = NULL,
#' @description
#' Create a new FAMD object
#' @param n_components Number of components
#' @return A new FAMD object
initialize = function(n_components = NULL){
self$n_components <- n_components
},
#' @description
#' Fit the FAMD model to data
#' @param data Dataframe
fit = function(data){
if (!is.data.frame(data)){
stop("Data are not in a dataframe format")
}
if (self$n_components == NULL){
self$n_components <- ncol(data)
}
self$model <- FactoMineR::FAMD(data, ncp=self$n_components, graph=FALSE)
invisible(self)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of new data coordinates
transform = function(data){
if (is.null(self$model)){
stop("Fit() method must be used before transform()")
}
coord <- predict(self$model, data)$coord
return(as.data.frame(coord[, 1:self$n_components]))
},
#' @description
#' Fit to data object then model it with FAMD
#' @param data Dataframe
#' @return Dataframe of new data coordinates
fit_transform = function(data){
self$fit(data)
self$transform(data)
}
),
)
?FAMD_
#' Simple qualitative NA imputer
#'
#' @description
#' Class of a qualitative NA imputer object that has fit, fit_transform and transform methods to impute qualitative missing values with mode or probabilistic method
#'
#' @details
#'
#' @import R6
#' @export
#'
#' @examples
#' imputer <- Simple.Quali.Imputer$new(imputation_type="mode")
#' imputer <- Simple.Quali.Imputer$new(imputation_type="probability")
#'
#' X_train_filled <- imputer$fit_transform(X_train, c("Col_quali_1","Col_quali_2","Col_quali_N"))
#'
#' imputer$fit(X_train, c("Col_quali_1","Col_quali_2","Col_quali_N"))
#' X_test_filled <- imputer$transform(X_test)
Simple.Quali.Imputer <- R6::R6Class("Simple.Quali.Imputer",
public = list(
#' @field imputation_type Method that will be used to impute NA
imputation_type = NULL,
#' @field imputation_values Values produced by the imputer
imputation_values = NULL,
#' @description
#' Create a new simple qualitative imputer object
#' @param imputation_type Method of NA imputation
#' @return A new imputer object
initialize = function(imputation_type = "mode") {
self$imputation_type <- imputation_type
},
#' @description
#' Fit the simple qualitative imputer to data following the specified method
#' @param data Dataframe
#' @param columns Vector of column names that will get imputation (must be of qualitative type)
fit = function(data, columns) {
self$imputation_values <- apply(data[columns], 2, function(x) {
if (self$imputation_type == "mode") {
Mode <- function(x, na.rm = FALSE) {
if (na.rm) {
x <- x[!is.na(x)]
}
unique_values <- unique(x)
frequencies <- tabulate(match(x, unique_values))
mode_values <- unique_values[frequencies == max(frequencies)]
return(mode_values)
}
Mode(x, na.rm = TRUE)
} else if (self$imputation_type == "probability") {
# Remove NA values for probability calculation
non_na_values <- x[!is.na(x)]
# Calculate probability distribution
prob_dist <- table(non_na_values) / length(non_na_values)
# Impute missing values
sample(
names(prob_dist),
sum(is.na(x)),
replace = TRUE,
prob = prob_dist
)
} else {
stop("Unsupported imputation type")
}
}
)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of data after imputation
transform = function(data) {
for (col in names(self$imputation_values)) {
data[[col]][is.na(data[[col]])] <- self$imputation_values[[col]]
}
return(data)
},
#' @description
#' Fit to data object following the specified method then impute NA
#' @param data Dataframe
#' @param columns Vector of column names that will get imputation (must be of qualitative type)
#' @return Dataframe of data after imputation
fit_transform = function(data, columns) {
self$fit(data, columns)
return(self$transform(data))
}
)
)
?Simple.Quali.Imputer
setwd("~/Data Science/Projets/R/RegLogMulti")
?Simple.Quali.Imputer
devtools::document()
#' Simple qualitative NA imputer
#'
#' @description
#' Class of a qualitative NA imputer object that has fit, fit_transform and transform methods to impute qualitative missing values with mode or probabilistic method
#'
#' @details
#'
#' @import R6
#' @export
#'
#' @examples
#' imputer <- Simple.Quali.Imputer$new(imputation_type="mode")
#' imputer <- Simple.Quali.Imputer$new(imputation_type="probability")
#'
#' X_train_filled <- imputer$fit_transform(X_train, c("Col_quali_1","Col_quali_2","Col_quali_N"))
#'
#' imputer$fit(X_train, c("Col_quali_1","Col_quali_2","Col_quali_N"))
#' X_test_filled <- imputer$transform(X_test)
Simple.Quali.Imputer <- R6::R6Class("Simple.Quali.Imputer",
public = list(
#' @field imputation_type Method that will be used to impute NA
imputation_type = NULL,
#' @field imputation_values Values produced by the imputer
imputation_values = NULL,
#' @description
#' Create a new simple qualitative imputer object
#' @param imputation_type Method of NA imputation
#' @return A new imputer object
initialize = function(imputation_type = "mode") {
self$imputation_type <- imputation_type
},
#' @description
#' Fit the simple qualitative imputer to data following the specified method
#' @param data Dataframe
#' @param columns Vector of column names that will get imputation (must be of qualitative type)
fit = function(data, columns) {
self$imputation_values <- apply(data[columns], 2, function(x) {
if (self$imputation_type == "mode") {
Mode <- function(x, na.rm = FALSE) {
if (na.rm) {
x <- x[!is.na(x)]
}
unique_values <- unique(x)
frequencies <- tabulate(match(x, unique_values))
mode_values <- unique_values[frequencies == max(frequencies)]
return(mode_values)
}
Mode(x, na.rm = TRUE)
} else if (self$imputation_type == "probability") {
# Remove NA values for probability calculation
non_na_values <- x[!is.na(x)]
# Calculate probability distribution
prob_dist <- table(non_na_values) / length(non_na_values)
# Impute missing values
sample(
names(prob_dist),
sum(is.na(x)),
replace = TRUE,
prob = prob_dist
)
} else {
stop("Unsupported imputation type")
}
}
)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of data after imputation
transform = function(data) {
for (col in names(self$imputation_values)) {
data[[col]][is.na(data[[col]])] <- self$imputation_values[[col]]
}
return(data)
},
#' @description
#' Fit to data object following the specified method then impute NA
#' @param data Dataframe
#' @param columns Vector of column names that will get imputation (must be of qualitative type)
#' @return Dataframe of data after imputation
fit_transform = function(data, columns) {
self$fit(data, columns)
return(self$transform(data))
}
)
)
?Simple.Quali.Imputer
#' Factor Analysis of Mixed Data
#'
#' @description
#' Class of a FAMD object that has fit, fit_transform and transform methods to embed the qualitative and quantitative features into a new quantitative coordinates system
#'
#' @details
#'
#' @import R6
#' @import FactoMineR
#' @export
#'
#' @examples
#' famd <- FAMD_$new()
#'
#' X_train_famd <- famd$fit_transform(X_train)
#'
#' famd$fit(X_train)
#' X_test_famd <- famd$transform(X_test)
FAMD_ <- R6::R6Class("FAMD_",
public = list(
#' @field model FAMD object
model = NULL,
#' @field n_components Number of components to keep from the new coordinates system
n_components = NULL,
#' @description
#' Create a new FAMD object
#' @param n_components Number of components
#' @return A new FAMD object
initialize = function(n_components = NULL){
self$n_components <- n_components
},
#' @description
#' Fit the FAMD model to data
#' @param data Dataframe
fit = function(data){
if (!is.data.frame(data)){
stop("Data are not in a dataframe format")
}
if (is.null(self$n_components)){
self$n_components <- ncol(data)
}
self$model <- FactoMineR::FAMD(data, ncp=self$n_components, graph=FALSE)
invisible(self)
},
#' @description
#' Transform the passed data object based on the fit data object
#' @param data Dataframe
#' @return Dataframe of new data coordinates
transform = function(data){
if (is.null(self$model)){
stop("Fit() method must be used before transform()")
}
coord <- predict(self$model, data)$coord
return(as.data.frame(coord[, 1:self$n_components]))
},
#' @description
#' Fit to data object then model it with FAMD
#' @param data Dataframe
#' @return Dataframe of new data coordinates
fit_transform = function(data){
self$fit(data)
self$transform(data)
}
),
)
?FAMD_
warnings()
roxygen2::roxygenize()
warnings()
roxygen2::roxygenize()
devtools::document()
roxygen2::roxygenize()
devtools::document()
devtools::document()
roxygen2::roxygenize()
devtools::document()
roxygen2::roxygenize()
devtools::document()
devtools::document()
roxygen2::roxygenize()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
roxygen2::roxygenize()
devtools::document()
warnings(... = )
warnings()
roxygen2::roxygenize()
roxygen2::roxygenize()
warnings()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
warnings()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
?Standard.Scaler
